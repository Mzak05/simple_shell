#include "shell.h"
/**
 * is_chain_del - test if current char in buffer is a chain delimeter
 * @infffo: the parameter struct
 * @bufbuf: the char buffer
 * @p: address of current position in buf
 * Return: 1 if chain delimeter, 0 otherwise
 */
int is_chain_del(info_type *infffo, char *bufbuf, size_t *p)
{
	size_t j = *p;

	if (bufbuf[j] == '|' && bufbuf[j + 1] == '|')
	{
		bufbuf[j] = 0;
		j++;
		infffo->cmd_buf_type = CMD_OR;
	}
	else if (bufbuf[j] == '&' && bufbuf[j + 1] == '&')
	{
		bufbuf[j] = 0;
		j++;
		infffo->cmd_buf_type = CMD_AND;
	}
	else if (bufbuf[j] == ';') /* found end of this command */
	{
		bufbuf[j] = 0; /* replace semicolon with null */
		infffo->cmd_buf_type = CMD_CHAIN;
	}
	else
		return (0);
	*p = j;
	return (1);
}

/**
 * check_chain - checks we should continue chaining based on last status
 * @infffo: the parameter struct
 * @bufbuf: the char buffer
 * @p: address of current position in buffer
 * @i: starting position in buf
 * @len: length of buffer
 *
 * Return: Void
 */
void check_chain(info_type *infffo, char *bufbuf, size_t *p, size_t i, size_t len)
{
	size_t j = *p;

	if (infffo->cmd_buf_type == CMD_AND)
	{
		if (infffo->status)
		{
			bufbuf[i] = 0;
			j = len;
		}
	}
	if (infffo->cmd_buf_type == CMD_OR)
	{
		if (!infffo->status)
		{
			bufbuf[i] = 0;
			j = len;
		}
	}

	*p = j;
}

/**
 * replace_alias - replaces an aliases in the tokenized string
 * @infffo: the parameter struct
 *
 * Return: 1 if replaced, 0 otherwise
 */
int replace_alias(info_type *infffo)
{
	int i;
	list_t *node;
	char *p;

	for (i = 0; i < 10; i++)
	{
		node = node_starts_with(infffo->alias, infffo->argv[0], '=');
		if (!node)
			return (0);
		free(infffo->argv[0]);
		p = _str_chr(node->str, '=');
		if (!p)
			return (0);
		p = _str_dup(p + 1);
		if (!p)
			return (0);
		infffo->argv[0] = p;
	}
	return (1);
}

/**
 * replace_vars_str - replaces vars in the tokenized string
 * @infffo: the parameter struct
 *
 * Return: 1 if replaced, 0 otherwise
 */
int replace_vars_str(info_type *infffo)
{
	int i = 0;
	list_t *node;

	for (i = 0; infffo->argv[i]; i++)
	{
		if (infffo->argv[i][0] != '$' || !infffo->argv[i][1])
			continue;

		if (!_str_comp(infffo->argv[i], "$?"))
		{
			replace_str(&(infffo->argv[i]),
				_str_dup(convert_number(infffo->status, 10, 0)));
			continue;
		}
		if (!_str_comp(infffo->argv[i], "$$"))
		{
			replace_str(&(infffo->argv[i]),
				_str_dup(convert_number(getpid(), 10, 0)));
			continue;
		}
		node = node_starts_with(infffo->env, &infffo->argv[i][1], '=');
		if (node)
		{
			replace_str(&(infffo->argv[i]),
				_str_dup(_str_chr(node->str, '=') + 1));
			continue;
		}
		replace_str(&infffo->argv[i], _str_dup(""));

	}
	return (0);
}

/**
 * replace_str - replaces string
 * @previous: address of old string
 * @next: new string
 *
 * Return: 1 if replaced, 0 otherwise
 */
int replace_str(char **previous, char *next)
{
	free(*previous);
	*previous = next;
	return (1);
}
#include "shell.h"
/**
 * _errors_sti - converts a string to an integer
 * @achstr: the string to be converted
 * Return: 0 if no numbers in string, converted number otherwise
 *       -1 on error
 */
int _errors_sti(char *achstr)
{
	int i = 0;
	unsigned long int result = 0;

	if (*achstr == '+')
		achstr++; 
	for (i = 0;  achstr[i] != '\0'; i++)
	{
		if (achstr[i] >= '0' && achstr[i] <= '9')
		{
			result *= 10;
			result += (achstr[i] - '0');
			if (result > INT_MAX)
				return (-1);
		}
		else
			return (-1);
	}
	return (result);
}

/**
 * print_error - prints an error message
 * @infffo: the parameter & return info struct
 * @badstr: string containing specified error type
 * Return: 0 if no numbers in string, converted number otherwise
 * -1 on error
 */
void print_error(info_type *infffo, char *badstr)
{
	_eput_str(infffo->fname);
	_eput_str(": ");
	print_decimal(infffo->line_count, STDERR_FILENO);
	_eput_str(": ");
	_eput_str(infffo->argv[0]);
	_eput_str(": ");
	_eput_str(badstr);
}

/**
 * print_decimal - function prints a decimal (integer) number (base 10)
 * @inpp: the input
 * @fd: the filedescriptor to write to
 * Return: number of characters
 */
int print_decimal(int inpp, int fd)
{
	int (*__putchar)(char) = _putchar;
	int i, c = 0;
	unsigned int _abs_, current;

	if (fd == STDERR_FILENO)
		__putchar = _eputchar;
	if (inpp < 0)
	{
		_abs_ = -inpp;
		__putchar('-');
		c++;
	}
	else
		_abs_ = inpp;
	current = _abs_;
	for (i = 100000000; i > 1; i /= 10)
	{
		if (_abs_ / i)
		{
			__putchar('0' + current / i);
			c++;
		}
		current %= i;
	}
	__putchar('0' + current);
	c++;

	return (c);
}

/**
 * convert_number - converter function, a clone of itoa
 * @numbobo: number
 * @base: base
 * @flags: argument flags
 *
 * Return: string
 */
char *convert_number(long int numbobo, int base, int rayas)
{
	static char *array;
	static char buffer[50];
	char sign = 0;
	char *p;
	unsigned long n = numbobo;

	if (!(rayas & CONVERT_UNSIGNED) && numbobo < 0)
	{
		n = -numbobo;
		sign = '-';

	}
	array = rayas & CONVERT_LOWERCASE ? "0123456789abcdef" : "0123456789ABCDEF";
	p = &buffer[49];
	*p = '\0';

	do	{
		*--p = array[n % base];
		n /= base;
	} while (n != 0);

	if (sign)
		*--p = sign;
	return (p);
}

/**
 * remove_comments - function replaces first instance of '#' with '\0'
 * @buf: address of the string to modify
 *
 * Return: Always 0;
 */
void remove_comments(char *bufbuf)
{
	int i;

	for (i = 0; bufbuf[i] != '\0'; i++)
		if (bufbuf[i] == '#' && (!i || bufbuf[i - 1] == ' '))
		{
			bufbuf[i] = '\0';
			break;
		}
}
#include "shell.h"
/**
 *_eput_str - prints an input string
 * @achstr: the string to be printed
 *
 * Return: Nothing
 */
void _eput_str(char *achstr)
{
	int i = 0;

	if (!achstr)
		return;
	while (achstr[i] != '\0')
	{
		_eputchar(achstr[i]);
		i++;
	}
}

/**
 * _eputchar - writes the character c to stderr
 * @caca: The character to print
 *
 * Return: On success 1.
 * On error, -1 is returned, and errno is set appropriately.
 */
int _eputchar(char caca)
{
	static int i;
	static char buf[WRITE_BUF_SIZE];

	if (caca == BUF_FLUSH || i >= WRITE_BUF_SIZE)
	{
		write(2, buf, i);
		i = 0;
	}
	if (caca != BUF_FLUSH)
		buf[i++] = caca;
	return (1);
}

/**
 * _put_fd - writes the character c to given fd
 * @caca: The character to print
 * @fd: The filedescriptor to write to
 *
 * Return: On success 1.
 * On error, -1 is returned, and errno is set appropriately.
 */
int _put_fd(char caca, int fd)
{
	static int i;
	static char buf[WRITE_BUF_SIZE];

	if (caca == BUF_FLUSH || i >= WRITE_BUF_SIZE)
	{
		write(fd, buf, i);
		i = 0;
	}
	if (caca != BUF_FLUSH)
		buf[i++] = caca;
	return (1);
}

/**
 *_puts_fd - prints an input string
 * @achstr: the string to be printed
 * @fd: the filedescriptor to write to
 *
 * Return: the number of chars put
 */
int _puts_fd(char *achstr, int fd)
{
	int i = 0;

	if (!achstr)
		return (0);
	while (*achstr)
	{
		i += _put_fd(*achstr++, fd);
	}
	return (i);
}
#include "shell.h"
/**
 *shell_loop - main shell loop
 * @infffo: the parameter & return info struct
 * @argv: the argument vector from main()
 *
 * Return: 0 on success, 1 on error, or error code
 */
int shell_loop(info_type *infffo, char **argv)
{
	ssize_t r = 0;
	int builtin_ret = 0;

	while (r != -1 && builtin_ret != -2)
	{
		clear_info(infffo);
		if (interactive(infffo))
			_puts("$ ");
		_eputchar(BUF_FLUSH);
		r = get_input(infffo);
		if (r != -1)
		{
			set_info(infffo, argv);
			builtin_ret = find_builtin_cmd(infffo);
			if (builtin_ret == -1)
				find_command(infffo);
		}
		else if (interactive(infffo))
			_putchar('\n');
		free_info(infffo, 0);
	}
	write_history(infffo);
	free_info(infffo, 1);
	if (!interactive(infffo) && infffo->status)
		exit(infffo->status);
	if (builtin_ret == -2)
	{
		if (infffo->err_num == -1)
			exit(infffo->status);
		exit(infffo->err_num);
	}
	return (builtin_ret);
}

/**
 * find_builtin_cmd - finds a builtin command
 * @infffo: the parameter & return info struct
 *
 * Return: -1 if builtin not found,
 *			0 if builtin executed successfully,
 *			1 if builtin found but not successful,
 *			-2 if builtin signals exit()
 */
int find_builtin_cmd(info_type *infffo)
{
	int i, built_in_ret = -1;
	builtin_table builtintbl[] = {
		{"exit", _myexit},
		{"env", _myenvir},
		{"help", _myhelp},
		{"history", _myhistory},
		{"setenv", _mysetenv},
		{"unsetenv", _my_unsetenv},
		{"cd", _mydir},
		{"alias", _myalias},
		{NULL, NULL}
	};

	for (i = 0; builtintbl[i].type; i++)
		if (_str_comp(infffo->argv[0], builtintbl[i].type) == 0)
		{
			infffo->line_count++;
			built_in_ret = builtintbl[i].func(infffo);
			break;
		}
	return (built_in_ret);
}

/**
 * find_command - finds a command in PATH
 * @infffo: the parameter & return info struct
 *
 * Return: void
 */
void find_command(info_type *infffo)
{
	char *path = NULL;
	int i, k;

	infffo->path = infffo->argv[0];
	if (infffo->linecount_flag == 1)
	{
		infffo->line_count++;
		infffo->linecount_flag = 0;
	}
	for (i = 0, k = 0; infffo->arg[i]; i++)
		if (!is_delim(infffo->arg[i], " \t\n"))
			k++;
	if (!k)
		return;

	path = find_path(infffo, _get_env(infffo, "PATH="), infffo->argv[0]);
	if (path)
	{
		infffo->path = path;
		fork_command(infffo);
	}
	else
	{
		if ((interactive(infffo) || _get_env(infffo, "PATH=")
			|| infffo->argv[0][0] == '/') && is_command(infffo, infffo->argv[0]))
			fork_command(infffo);
		else if (*(infffo->arg) != '\n')
		{
			infffo->status = 127;
			print_error(infffo, "not found\n");
		}
	}
}

/**
 * fork_command - forks a an exec thread to run cmd
 * @infffo: the parameter & return info struct
 *
 * Return: void
 */
void fork_command(info_type *infffo)
{
	pid_t child_pid;

	child_pid = fork();
	if (child_pid == -1)
	{
		/* TODO: PUT ERROR FUNCTION */
		perror("Error:");
		return;
	}
	if (child_pid == 0)
	{
		if (execve(infffo->path, infffo->argv, get_env(infffo)) == -1)
		{
			free_info(infffo, 1);
			if (errno == EACCES)
				exit(126);
			exit(1);
		}
		/* TODO: PUT ERROR FUNCTION */
	}
	else
	{
		wait(&(infffo->status));
		if (WIFEXITED(infffo->status))
		{
			infffo->status = WEXITSTATUS(infffo->status);
			if (infffo->status == 126)
				print_error(infffo, "Permission denied\n");
		}
	}
}
#include "shell.h"
/**
 * ptr_free - frees a pointer and NULLs the address
 * @padr: address of the pointer to free
 *
 * Return: 1 if freed, otherwise 0.
 */
int ptr_free(void **padr)
{
	if (padr && *padr)
	{
		free(*padr);
		*padr = NULL;
		return (1);
	}
	return (0);
}
#include "shell.h"
/**
 * get_env - returns the string array copy of our environ
 * @infffo: Structure containing potential arguments
 * Return: Always 0
 */
char **get_env(info_type *infffo)
{
	if (!infffo->environ || infffo->env_changed)
	{
		infffo->environ = list_to_str(infffo->env);
		infffo->env_changed = 0;
	}

	return (infffo->environ);
}

/**
 * _unsetenv - Remove an environment variable
 * @infffo: Structure containing potential arguments
 *  Return: 1 on delete, 0 otherwise
 * @varia: the string env var property
 */
int _unsetenv(info_type *infffo, char *varia)
{
	list_t *node = infffo->env;
	size_t i = 0;
	char *ptr;

	if (!node || !varia)
		return (0);

	while (node)
	{
		ptr = starts_with(node->str, varia);
		if (ptr && *ptr == '=')
		{
			infffo->env_changed = delete_node(&(infffo->env), i);
			i = 0;
			node = infffo->env;
			continue;
		}
		node = node->next;
		i++;
	}
	return (infffo->env_changed);
}

/**
 * _setenviro - Initialize a new environment variable,
 *             or modify an existing one
 * @infffo: Structure containing potential arguments. Used to maintain
 *        constant function prototype.
 * @varia: the string env var property
 * @value: the string env var value
 *  Return: Always 0
 */
int _setenviro(info_type *infffo, char *varia, char *val)
{
	char *buffer = NULL;
	list_t *node;
	char *ptr;

	if (!varia || !val)
		return (0);

	buffer = malloc(_strlength(varia) + _strlength(val) + 2);
	if (!buffer)
		return (1);
	_str_copy(buffer, varia);
	_str_cat(buffer, "=");
	_str_cat(buffer, val);
	node = infffo->env;
	while (node)
	{
		ptr = starts_with(node->str, varia);
		if (ptr && *ptr == '=')
		{
			free(node->str);
			node->str = buffer;
			infffo->env_changed = 1;
			return (0);
		}
		node = node->next;
	}
	add_node_end(&(infffo->env), buffer, 0);
	free(buffer);
	infffo->env_changed = 1;
	return (0);
}
#include "shell.h"
/**
 * get_history_f - gets the history file
 * @infffo: parameter struct
 *
 * Return: allocated string containg history file
 */

char *get_history_f(info_type *infffo)
{
	char *bufbuf, *dir;

	dir = _get_env(infffo, "HOME=");
	if (!dir)
		return (NULL);
	bufbuf = malloc(sizeof(char) * (_strlength(dir) + _strlength(HIST_FILE) + 2));
	if (!bufbuf)
		return (NULL);
	bufbuf[0] = 0;
	_str_copy(bufbuf, dir);
	_str_cat(bufbuf, "/");
	_str_cat(bufbuf, HIST_FILE);
	return (bufbuf);
}

/**
 * write_history - creates a file, or appends to an existing file
 * @infffo: the parameter struct
 *
 * Return: 1 on success, else -1
 */
int write_history(info_type *infffo)
{
	ssize_t fd;
	char *filename = get_history_f(infffo);
	list_t *node = NULL;

	if (!filename)
		return (-1);

	fd = open(filename, O_CREAT | O_TRUNC | O_RDWR, 0644);
	free(filename);
	if (fd == -1)
		return (-1);
	for (node = infffo->history; node; node = node->next)
	{
		_puts_fd(node->str, fd);
		_put_fd('\n', fd);
	}
	_put_fd(BUF_FLUSH, fd);
	close(fd);
	return (1);
}

/**
 * read_hist - reads history from file
 * @infffo: the parameter struct
 *
 * Return: histcount on success, 0 otherwise
 */
int read_hist(info_type *infffo)
{
	int i, last = 0, linecount = 0;
	ssize_t fd, rdlen, fsize = 0;
	struct stat st;
	char *bufbuf = NULL, *filename = get_history_f(infffo);

	if (!filename)
		return (0);

	fd = open(filename, O_RDONLY);
	free(filename);
	if (fd == -1)
		return (0);
	if (!fstat(fd, &st))
		fsize = st.st_size;
	if (fsize < 2)
		return (0);
	bufbuf = malloc(sizeof(char) * (fsize + 1));
	if (!bufbuf)
		return (0);
	rdlen = read(fd, bufbuf, fsize);
	bufbuf[fsize] = 0;
	if (rdlen <= 0)
		return (free(bufbuf), 0);
	close(fd);
	for (i = 0; i < fsize; i++)
		if (bufbuf[i] == '\n')
		{
			bufbuf[i] = 0;
			build_history_l(infffo, bufbuf + last, linecount++);
			last = i + 1;
		}
	if (last != i)
		build_history_l(infffo, bufbuf + last, linecount++);
	free(bufbuf);
	infffo->histcount = linecount;
	while (infffo->histcount-- >= HIST_MAX)
		delete_node(&(infffo->history), 0);
	renumber_history(infffo);
	return (infffo->histcount);
}

/**
 * build_history_l - adds entry to a history linked list
 * @infffo: Structure containing potential arguments. Used to maintain
 * @bufbuf: buffer
 * @linecount: the history linecount, histcount
 *
 * Return: Always 0
 */
int build_history_l(info_type *infffo, char *buf, int linecount)
{
	list_t *node = NULL;

	if (infffo->history)
		node = infffo->history;
	add_node_end(&node, buf, linecount);

	if (!infffo->history)
		infffo->history = node;
	return (0);
}

/**
 * renumber_history - renumbers the history linked list after changes
 * @infffo: Structure containing potential arguments. Used to maintain
 *
 * Return: the new histcount
 */
int renumber_history(info_type *infffo)
{
	list_t *node = infffo->history;
	int i = 0;

	while (node)
	{
		node->num = i++;
		node = node->next;
	}
	return (infffo->histcount = i);
}
#include "shell.h"
/**
 * clear_info - initializes info_type struct
 * @infffo: struct address
 */
void clear_info(info_type *infffo)
{
	infffo->arg = NULL;
	infffo->argv = NULL;
	infffo->path = NULL;
	infffo->argc = 0;
}

/**
 * set_info - initializes info_type struct
 * @infffo: struct address
 * @argv: argument vector
 */
void set_info(info_type *infffo, char **argv)
{
	int i = 0;

	infffo->fname = argv[0];
	if (infffo->arg)
	{
		infffo->argv = str_split(infffo->arg, " \t");
		if (!infffo->argv)
		{

			infffo->argv = malloc(sizeof(char *) * 2);
			if (infffo->argv)
			{
				infffo->argv[0] = _str_dup(infffo->arg);
				infffo->argv[1] = NULL;
			}
		}
		for (i = 0; infffo->argv && infffo->argv[i]; i++)
			;
		infffo->argc = i;

		replace_alias(infffo);
		replace_vars_str(infffo);
	}
}

/**
 * free_info - frees info_type struct fields
 * @infffo: struct address
 * @all: true if freeing all fields
 */
void free_info(info_type *infffo, int all)
{
	str_free(infffo->argv);
	infffo->argv = NULL;
	infffo->path = NULL;
	if (all)
	{
		if (!infffo->cmd_buf)
			free(infffo->arg);
		if (infffo->env)
			free_list(&(infffo->env));
		if (infffo->history)
			free_list(&(infffo->history));
		if (infffo->alias)
			free_list(&(infffo->alias));
		str_free(infffo->environ);
			infffo->environ = NULL;
		ptr_free((void **)infffo->cmd_buf);
		if (infffo->readfd > 2)
			close(infffo->readfd);
		_putchar(BUF_FLUSH);
	}
}
#include "shell.h"
/**
 * input_buf - buffers chained commands
 * @infffo: parameter struct
 * @bufbuf: address of buffer
 * @len: address of len var
 *
 * Return: bytes read
 */
ssize_t input_buf(info_type *infffo, char **bufbuf, size_t *len)
{
	ssize_t r = 0;
	size_t len_p = 0;

	if (!*len) 
	{
	
		free(*bufbuf);
		*bufbuf = NULL;
		signal(SIGINT, sigintHandler);
#if USE_GETLINE
		r = getline(bufbuf, &len_p, stdin);
#else
		r = _getline(infffo, bufbuf, &len_p);
#endif
		if (r > 0)
		{
			if ((*bufbuf)[r - 1] == '\n')
			{
				(*bufbuf)[r - 1] = '\0'; 
				r--;
			}
			infffo->linecount_flag = 1;
			remove_comments(*bufbuf);
			build_history_l(infffo, *bufbuf, infffo->histcount++);
			
			{
				*len = r;
				infffo->cmd_buf = bufbuf;
			}
		}
	}
	return (r);
}

/**
 * get_input - gets a line minus the newline
 * @infffo: parameter struct
 *
 * Return: bytes read
 */
ssize_t get_input(info_type *infffo)
{
	static char *bufbuf; 
	static size_t i, j, len;
	ssize_t r = 0;
	char **buf_p = &(infffo->arg), *p;

	_putchar(BUF_FLUSH);
	r = input_buf(infffo, &bufbuf, &len);
	if (r == -1) 
		return (-1);
	if (len)	
	{
		j = i; 
		p = bufbuf + i; 
		check_chain(infffo, bufbuf, &j, i, len);
		while (j < len) 
		{
			if (is_chain_del(infffo, bufbuf, &j))
				break;
			j++;
		}

		i = j + 1; 
		if (i >= len) 
		{
			i = len = 0; 
			infffo->cmd_buf_type = CMD_NORM;
		}

		*buf_p = p; 
		return (_strlength(p)); 
	}

	*buf_p = bufbuf; 
	return (r); 
}

/**
 * read_buf - reads a buffer
 * @infffo: parameter struct
 * @bufbuf: buffer
 * @i: size
 *
 * Return: r
 */
ssize_t read_buf(info_type *infffo, char *bufbuf, size_t *i)
{
	ssize_t r = 0;

	if (*i)
		return (0);
	r = read(infffo->readfd, bufbuf, READ_BUF_SIZE);
	if (r >= 0)
		*i = r;
	return (r);
}

/**
 * _getline - gets the next line of input from STDIN
 * @infffo: parameter struct
 * @ptr: address of pointer to buffer, preallocated or NULL
 * @length: size of preallocated ptr buffer if not NULL
 *
 * Return: s
 */
int _getline(info_type *infffo, char **ptr, size_t *length)
{
	static char bufbuf[READ_BUF_SIZE];
	static size_t i, len;
	size_t k;
	ssize_t r = 0, s = 0;
	char *p = NULL, *new_p = NULL, *c;

	p = *ptr;
	if (p && length)
		s = *length;
	if (i == len)
		i = len = 0;

	r = read_buf(infffo, bufbuf, &len);
	if (r == -1 || (r == 0 && len == 0))
		return (-1);

	c = _str_chr(bufbuf + i, '\n');
	k = c ? 1 + (unsigned int)(c - bufbuf) : len;
	new_p = _realloc(p, s, s ? s + k : k + 1);
	if (!new_p) 
		return (p ? free(p), -1 : -1);

	if (s)
		_strncat(new_p, bufbuf + i, k - i);
	else
		_strn_copy(new_p, bufbuf + i, k - i + 1);

	s += k - i;
	i = k;
	p = new_p;

	if (length)
		*length = s;
	*ptr = p;
	return (s);
}

/**
 * sigintHandler - blocks ctrl-C
 * @sig_num: the signal number
 *
 * Return: void
 */
void sigintHandler(__attribute__((unused))int sig_num)
{
	_puts("\n");
	_puts("$ ");
	_putchar(BUF_FLUSH);
}
#include "shell.h"
/**
 * add_node - adds a node to the start of the list
 * @first: address of pointer to first node
 * @achstr: str field of node
 * @num: node index used by history
 *
 * Return: size of list
 */
list_t *add_node(list_t **first, const char *achstr, int num)
{
	list_t *new_head;

	if (!first)
		return (NULL);
	new_head = malloc(sizeof(list_t));
	if (!new_head)
		return (NULL);
	_memory_set((void *)new_head, 0, sizeof(list_t));
	new_head->num = num;
	if (achstr)
	{
		new_head->str = _str_dup(achstr);
		if (!new_head->str)
		{
			free(new_head);
			return (NULL);
		}
	}
	new_head->next = *first;
	*first = new_head;
	return (new_head);
}

/**
 * add_node_end - adds a node to the end of the list
 * @first: address of pointer to first node
 * @achstr: str field of node
 * @num: node index used by history
 *
 * Return: size of list
 */
list_t *add_node_end(list_t **first, const char *achstr, int num)
{
	list_t *new_node, *node;

	if (!first)
		return (NULL);

	node = *first;
	new_node = malloc(sizeof(list_t));
	if (!new_node)
		return (NULL);
	_memory_set((void *)new_node, 0, sizeof(list_t));
	new_node->num = num;
	if (achstr)
	{
		new_node->str = _str_dup(achstr);
		if (!new_node->str)
		{
			free(new_node);
			return (NULL);
		}
	}
	if (node)
	{
		while (node->next)
			node = node->next;
		node->next = new_node;
	}
	else
		*first = new_node;
	return (new_node);
}

/**
 * prt_list_str - prints only the str element of a list_t linked list
 * @h: pointer to first node
 *
 * Return: size of list
 */
size_t prt_list_str(const list_t *h)
{
	size_t i = 0;

	while (h)
	{
		_puts(h->str ? h->str : "(nil)");
		_puts("\n");
		h = h->next;
		i++;
	}
	return (i);
}

/**
 * delete_node - deletes node at given index
 * @first: address of pointer to first node
 * @index: index of node to delete
 *
 * Return: 1 on success, 0 on failure
 */
int delete_node(list_t **first, unsigned int index)
{
	list_t *node, *prev_node;
	unsigned int i = 0;

	if (!first || !*first)
		return (0);

	if (!index)
	{
		node = *first;
		*first = (*first)->next;
		free(node->str);
		free(node);
		return (1);
	}
	node = *first;
	while (node)
	{
		if (i == index)
		{
			prev_node->next = node->next;
			free(node->str);
			free(node);
			return (1);
		}
		i++;
		prev_node = node;
		node = node->next;
	}
	return (0);
}

/**
 * free_list - frees all nodes of a list
 * @head_ptr: address of pointer to first node
 *
 * Return: void
 */
void free_list(list_t **head_ptr)
{
	list_t *node, *next_node, *first;

	if (!head_ptr || !*head_ptr)
		return;
	first = *head_ptr;
	node = first;
	while (node)
	{
		next_node = node->next;
		free(node->str);
		free(node);
		node = next_node;
	}
	*head_ptr = NULL;
}
#include "shell.h"
/**
 * is_command - determines if a file is an executable command
 * @infffo: the info struct
 * @path: path to the file
 *
 * Return: 1 if true, 0 otherwise
 */
int is_command(info_type *infffo, char *path)
{
	struct stat st;

	(void)infffo;
	if (!path || stat(path, &st))
		return (0);

	if (st.st_mode & __S_IFREG)
	{
		return (1);
	}
	return (0);
}

/**
 * dupli_chars - dupliicates characters
 * @pathstr: the PATH string
 * @start: starting index
 * @stop: stopping index
 *
 * Return: pointer to new buffer
 */
char *dupli_chars(char *pathstr, int start, int stop)
{
	static char buf[1024];
	int i = 0, k = 0;

	for (k = 0, i = start; i < stop; i++)
		if (pathstr[i] != ':')
			buf[k++] = pathstr[i];
	buf[k] = 0;
	return (buf);
}

/**
 * find_path - finds this cmd in the PATH string
 * @infffo: the info struct
 * @pathstr: the PATH string
 * @cmd: the cmd to find
 *
 * Return: full path of cmd if found or NULL
 */
char *find_path(info_type *infffo, char *pathstr, char *cmd)
{
	int i = 0, curr_pos = 0;
	char *path;

	if (!pathstr)
		return (NULL);
	if ((_strlength(cmd) > 2) && starts_with(cmd, "./"))
	{
		if (is_command(infffo, cmd))
			return (cmd);
	}
	while (1)
	{
		if (!pathstr[i] || pathstr[i] == ':')
		{
			path = dupli_chars(pathstr, curr_pos, i);
			if (!*path)
				_str_cat(path, cmd);
			else
			{
				_str_cat(path, "/");
				_str_cat(path, cmd);
			}
			if (is_command(infffo, path))
				return (path);
			if (!pathstr[i])
				break;
			curr_pos = i;
		}
		i++;
	}
	return (NULL);
}
#include "shell.h"
/**
 * interactive - returns true if shell is interactive mode
 * @infffo: struct address
 *
 * Return: 1 if interactive mode, 0 otherwise
 */
int interactive(info_type *infffo)
{
	return (isatty(STDIN_FILENO) && infffo->readfd <= 2);
}

/**
 * is_delim - checks if character is a delimeter
 * @caca: the char to check
 * @delim: the delimeter string
 * Return: 1 if true, 0 if false
 */
int is_delim(char caca, char *delim)
{
	while (*delim)
		if (*delim++ == caca)
			return (1);
	return (0);
}

/**
 *_is_alpha - checks for alphabetic character
 *@caca: The character to input
 *Return: 1 if caca is alphabetic, 0 otherwise
 */

int _is_alpha(int caca)
{
	if ((caca >= 'a' && caca <= 'z') || (caca >= 'A' && caca <= 'Z'))
		return (1);
	else
		return (0);
}

/**
 *_sti - converts a string to an integer
 *@achstr: the string to be converted
 *Return: 0 if no numbers in string, converted number otherwise
 */

int _sti(char *achstr)
{
	int i, sign = 1, flag = 0, output;
	unsigned int result = 0;

	for (i = 0;  achstr[i] != '\0' && flag != 2; i++)
	{
		if (achstr[i] == '-')
			sign *= -1;

		if (achstr[i] >= '0' && achstr[i] <= '9')
		{
			flag = 1;
			result *= 10;
			result += (achstr[i] - '0');
		}
		else if (flag == 1)
			flag = 2;
	}

	if (sign == -1)
		output = -result;
	else
		output = result;

	return (output);
}
#include "shell.h"
/**
 * list_len - determines length of linked list
 * @pt: pointer to first node
 *
 * Return: size of list
 */
size_t list_len(const list_t *pt)
{
	size_t i = 0;

	while (pt)
	{
		pt = pt->next;
		i++;
	}
	return (i);
}

/**
 * list_to_str - returns an array of strings of the list->str
 * @first: pointer to first node
 *
 * Return: array of strings
 */
char **list_to_str(list_t *first)
{
	list_t *node = first;
	size_t i = list_len(first), j;
	char **strs;
	char *str;

	if (!first || !i)
		return (NULL);
	strs = malloc(sizeof(char *) * (i + 1));
	if (!strs)
		return (NULL);
	for (i = 0; node; node = node->next, i++)
	{
		str = malloc(_strlength(node->str) + 1);
		if (!str)
		{
			for (j = 0; j < i; j++)
				free(strs[j]);
			free(strs);
			return (NULL);
		}

		str = _str_copy(str, node->str);
		strs[i] = str;
	}
	strs[i] = NULL;
	return (strs);
}


/**
 * print_list - prints all elements of a list_t linked list
 * @pt: pointer to first node
 *
 * Return: size of list
 */
size_t print_list(const list_t *pt)
{
	size_t i = 0;

	while (pt)
	{
		_puts(convert_number(pt->num, 10, 0));
		_putchar(':');
		_putchar(' ');
		_puts(pt->str ? pt->str : "(nil)");
		_puts("\n");
		pt = pt->next;
		i++;
	}
	return (i);
}

/**
 * node_starts_with - returns node whose string starts with prefix
 * @node: pointer to list head
 * @prefix: string to match
 * @caca: the next character after prefix to match
 *
 * Return: match node or null
 */
list_t *node_starts_with(list_t *node, char *prefix, char caca)
{
	char *p = NULL;

	while (node)
	{
		p = starts_with(node->str, prefix);
		if (p && ((caca == -1) || (*p == caca)))
			return (node);
		node = node->next;
	}
	return (NULL);
}

/**
 * get_node - gets the index of a node
 * @first: pointer to list head
 * @node: pointer to the node
 *
 * Return: index of node or -1
 */
ssize_t get_node(list_t *first, list_t *node)
{
	size_t i = 0;

	while (first)
	{
		if (first == node)
			return (i);
		first = first->next;
		i++;
	}
	return (-1);
}
#include "shell.h"
/**
 * main - entry point
 * @ac: arg count
 * @argv: arg vector
 *
 * Return: 0 on success, 1 on error
 */
int main(int ac, char **argv)
{
	info_type info[] = { INFO_INIT };
	int fdes = 2;

	asm ("mov %1, %0\n\t"
		"add $3, %0"
		: "=r" (fdes)
		: "r" (fdes));

	if (ac == 2)
	{
		fdes = open(argv[1], O_RDONLY);
		if (fdes == -1)
		{
			if (errno == EACCES)
				exit(126);
			if (errno == ENOENT)
			{
				_eput_str(argv[0]);
				_eput_str(": 0: Can't open ");
				_eput_str(argv[1]);
				_eputchar('\n');
				_eputchar(BUF_FLUSH);
				exit(127);
			}
			return (EXIT_FAILURE);
		}
		info->readfd = fdes;
	}
	p_env_list(info);
	read_hist(info);
	shell_loop(info, argv);
	return (EXIT_SUCCESS);
}
#include "shell.h"
/**
 **_memory_set - fills memory with a constant byte
 *@ptr: the pointer to the memory area
 *@by: the byte to fill *s with
 *@n: the amount of bytes to be filled
 *Return: (s) a pointer to the memory area s
 */
char *_memory_set(char *ptr, char by, unsigned int nb)
{
	unsigned int i;

	for (i = 0; i < nb; i++)
		ptr[i] = by;
	return (ptr);
}

/**
 * str_free - frees a string of strings
 * @sos: string of strings
 */
void str_free(char **sos)
{
	char **a = sos;

	if (!sos)
		return;
	while (*sos)
		free(*sos++);
	free(a);
}

/**
 * _realloc - reallocates a block of memory
 * @ptr: pointer to previous malloc'ated block
 * @oldsz: byte size of previous block
 * @newsz: byte size of new block
 *
 * Return: pointer to da ol'block nameen.
 */
void *_realloc(void *ptr, unsigned int oldsz, unsigned int newsz)
{
	char *p;

	if (!ptr)
		return (malloc(newsz));
	if (!newsz)
		return (free(ptr), NULL);
	if (newsz == oldsz)
		return (ptr);

	p = malloc(newsz);
	if (!p)
		return (NULL);

	oldsz = oldsz < newsz ? oldsz : newsz;
	while (oldsz--)
		p[oldsz] = ((char *)ptr)[oldsz];
	free(ptr);
	return (p);
}
#include "shell.h"
/**
 * _myexit - exits the shell
 * @infffo: Structure containing potential arguments
 *  Return: exits with a given exit status
 */
int _myexit(info_type *infffo)
{
	int exit_check;

	if (infffo->argv[1])  
	{
		exit_check = _errors_sti(infffo->argv[1]);
		if (exit_check == -1)
		{
			infffo->status = 2;
			print_error(infffo, "Illegal number: ");
			_eput_str(infffo->argv[1]);
			_eputchar('\n');
			return (1);
		}
		infffo->err_num = _errors_sti(infffo->argv[1]);
		return (-2);
	}
	infffo->err_num = -1;
	return (-2);
}

/**
 * _mydir - changes the current directory of the process
 * @infffo: Structure containing potential arguments
 *  Return: Always 0
 */
int _mydir(info_type *infffo)
{
	char *s, *dir, buffer[1024];
	int chdir_rt;

	s = getcwd(buffer, 1024);
	if (!s)
		_puts("TODO: >>getcwd failure emsg here<<\n");
	if (!infffo->argv[1])
	{
		dir = _get_env(infffo, "HOME=");
		if (!dir)
			chdir_rt = 
				chdir((dir = _get_env(infffo, "PWD=")) ? dir : "/");
		else
			chdir_rt = chdir(dir);
	}
	else if (_str_comp(infffo->argv[1], "-") == 0)
	{
		if (!_get_env(infffo, "OLDPWD="))
		{
			_puts(s);
			_putchar('\n');
			return (1);
		}
		_puts(_get_env(infffo, "OLDPWD=")), _putchar('\n');
		chdir_rt = 
			chdir((dir = _get_env(infffo, "OLDPWD=")) ? dir : "/");
	}
	else
		chdir_rt = chdir(infffo->argv[1]);
	if (chdir_rt == -1)
	{
		print_error(infffo, "can't cd to ");
		_eput_str(infffo->argv[1]), _eputchar('\n');
	}
	else
	{
		_setenviro(infffo, "OLDPWD", _get_env(infffo, "PWD="));
		_setenviro(infffo, "PWD", getcwd(buffer, 1024));
	}
	return (0);
}

/**
 * _myhelp - changes the current directory of the process
 * @infffo: Structure containing potential arguments
 *  Return: Always 0
 */
int _myhelp(info_type *infffo)
{
	char **arg_arr;

	arg_arr = infffo->argv;
	_puts("help call works. Function not yet implemented \n");
	if (0)
		_puts(*arg_arr);
	return (0);
}
#include "shell.h"
/**
 * _myenvir - prints the current environment
 * @infffo: Structure containing potential arguments
 * Return: Always 0
 */
int _myenvir(info_type *infffo)
{
	prt_list_str(infffo->env);
	return (0);
}

/**
 * _get_env - gets the value of an environ variable
 * @infffo: Structure containing potential arguments
 * @envname: env var name
 *
 * Return: the value
 */
char *_get_env(info_type *infffo, const char *envname)
{
	list_t *node = infffo->env;
	char *x;

	while (node)
	{
		x = starts_with(node->str, envname);
		if (x && *x)
			return (x);
		node = node->next;
	}
	return (NULL);
}

/**
 * _mysetenv - Initialize a new environment variable
 * @infffo: Structure containing potential arguments
 *  Return: Always 0
 */
int _mysetenv(info_type *infffo)
{
	if (infffo->argc != 3)
	{
		_eput_str("Incorrect number of arguements\n");
		return (1);
	}
	if (_setenviro(infffo, infffo->argv[1], infffo->argv[2]))
		return (0);
	return (1);
}

/**
 * _my_unsetenv - Remove an environment variable
 * @infffo: Structure containing potential arguments
 *  Return: Always 0
 */
int _my_unsetenv(info_type *infffo)
{
	int i;

	if (infffo->argc == 1)
	{
		_eput_str("Too few arguements.\n");
		return (1);
	}
	for (i = 1; i <= infffo->argc; i++)
		_unsetenv(infffo, infffo->argv[i]);

	return (0);
}

/**
 * p_env_list - populates env linked list
 * @infffo: Structure containing potential arguments
 * Return: Always 0
 */
int p_env_list(info_type *infffo)
{
	list_t *node = NULL;
	size_t i;

	for (i = 0; environ[i]; i++)
		add_node_end(&node, environ[i], 0);
	infffo->env = node;
	return (0);
}
#include "shell.h"
/**
 * _myhistory - displays the history list, one command by line, preceded
 * with line numbers, starting at 0.
 * @infffo: Structure containing potential arguments
 *  Return: Always 0
 */
int _myhistory(info_type *infffo)
{
	print_list(infffo->history);
	return (0);
}

/**
 * unset_alias - sets alias to string
 * @infffo: parameter struct
 * @achstr: the string alias
 *
 * Return: Always 0 on success, 1 on error
 */
int unset_alias(info_type *infffo, char *achstr)
{
	char *p, c;
	int ret;

	p = _str_chr(achstr, '=');
	if (!p)
		return (1);
	c = *p;
	*p = 0;
	ret = delete_node(&(infffo->alias),
		get_node(infffo->alias, node_starts_with(infffo->alias, achstr, -1)));
	*p = c;
	return (ret);
}

/**
 * set_alias - sets alias to string
 * @infffo: parameter struct
 * @achstr: the string alias
 *
 * Return: Always 0 on success, 1 on error
 */
int set_alias(info_type *infffo, char *achstr)
{
	char *p;

	p = _str_chr(achstr, '=');
	if (!p)
		return (1);
	if (!*++p)
		return (unset_alias(infffo, achstr));

	unset_alias(infffo, achstr);
	return (add_node_end(&(infffo->alias), achstr, 0) == NULL);
}

/**
 * print_alias - prints an alias string
 * @node: the alias node
 *
 * Return: Always 0 on success, 1 on error
 */
int print_alias(list_t *node)
{
	char *p = NULL, *a = NULL;

	if (node)
	{
		p = _str_chr(node->str, '=');
		for (a = node->str; a <= p; a++)
			_putchar(*a);
		_putchar('\'');
		_puts(p + 1);
		_puts("'\n");
		return (0);
	}
	return (1);
}

/**
 * _myalias - mimics the alias builtin (man alias)
 * @infffo: Structure containing potential arguments.
 *  Return: Always 0
 */
int _myalias(info_type *infffo)
{
	int i = 0;
	char *p = NULL;
	list_t *node = NULL;

	if (infffo->argc == 1)
	{
		node = infffo->alias;
		while (node)
		{
			print_alias(node);
			node = node->next;
		}
		return (0);
	}
	for (i = 1; infffo->argv[i]; i++)
	{
		p = _str_chr(infffo->argv[i], '=');
		if (p)
			set_alias(infffo, infffo->argv[i]);
		else
			print_alias(node_starts_with(infffo->alias, infffo->argv[i], '='));
	}

	return (0);
}
#include "shell.h"
/**
 * **str_split - splits a string into words. Repeat delimiters are ignored
 * @achstr: the input string
 * @dli: the delimeter string
 * Return: a pointer to an array of strings, or NULL on failure
 */

char **str_split(char *achstr, char *dli)
{
	int i, j, k, m, numwords = 0;
	char **s;

	if (achstr == NULL || achstr[0] == 0)
		return (NULL);
	if (!dli)
		dli = " ";
	for (i = 0; achstr[i] != '\0'; i++)
		if (!is_delim(achstr[i], dli) && (is_delim(achstr[i + 1], dli) || !achstr[i + 1]))
			numwords++;

	if (numwords == 0)
		return (NULL);
	s = malloc((1 + numwords) * sizeof(char *));
	if (!s)
		return (NULL);
	for (i = 0, j = 0; j < numwords; j++)
	{
		while (is_delim(achstr[i], dli))
			i++;
		k = 0;
		while (!is_delim(achstr[i + k], dli) && achstr[i + k])
			k++;
		s[j] = malloc((k + 1) * sizeof(char));
		if (!s[j])
		{
			for (k = 0; k < j; k++)
				free(s[k]);
			free(s);
			return (NULL);
		}
		for (m = 0; m < k; m++)
			s[j][m] = achstr[i++];
		s[j][m] = 0;
	}
	s[j] = NULL;
	return (s);
}

/**
 * **str_split2 - splits a string into words
 * @achstr: the input string
 * @dli: the delimeter
 * Return: a pointer to an array of strings, or NULL on failure
 */
char **str_split2(char *achstr, char dli)
{
	int i, j, k, m, numwords = 0;
	char **s;

	if (achstr == NULL || achstr[0] == 0)
		return (NULL);
	for (i = 0; achstr[i] != '\0'; i++)
		if ((achstr[i] != dli && achstr[i + 1] == dli) ||
		    (achstr[i] != dli && !achstr[i + 1]) || achstr[i + 1] == dli)
			numwords++;
	if (numwords == 0)
		return (NULL);
	s = malloc((1 + numwords) * sizeof(char *));
	if (!s)
		return (NULL);
	for (i = 0, j = 0; j < numwords; j++)
	{
		while (achstr[i] == dli && achstr[i] != dli)
			i++;
		k = 0;
		while (achstr[i + k] != dli && achstr[i + k] && achstr[i + k] != dli)
			k++;
		s[j] = malloc((k + 1) * sizeof(char));
		if (!s[j])
		{
			for (k = 0; k < j; k++)
				free(s[k]);
			free(s);
			return (NULL);
		}
		for (m = 0; m < k; m++)
			s[j][m] = achstr[i++];
		s[j][m] = 0;
	}
	s[j] = NULL;
	return (s);
}
#include "shell.h"
/**
 * _str_copy - copies a string
 * @desti: the destination
 * @sbuf: the source
 *
 * Return: pointer to destination
 */
char *_str_copy(char *desti, char *sbuf)
{
	int i = 0;

	if (desti == sbuf || sbuf == 0)
		return (desti);
	while (sbuf[i])
	{
		desti[i] = sbuf[i];
		i++;
	}
	desti[i] = 0;
	return (desti);
}

/**
 * _str_dup - duplicates a string
 * @dupstr: the string to duplicate
 *
 * Return: pointer to the duplicated string
 */
char *_str_dup(const char *dupstr)
{
	int length = 0;
	char *ret;

	if (dupstr == NULL)
		return (NULL);
	while (*dupstr++)
		length++;
	ret = malloc(sizeof(char) * (length + 1));
	if (!ret)
		return (NULL);
	for (length++; length--;)
		ret[length] = *--dupstr;
	return (ret);
}

/**
 *_puts - prints an input string
 *@prstr: the string to be printed
 *
 * Return: Nothing
 */
void _puts(char *prstr)
{
	int i = 0;

	if (!prstr)
		return;
	while (prstr[i] != '\0')
	{
		_putchar(prstr[i]);
		i++;
	}
}

/**
 * _putchar - writes the character c to stdout
 * @cp: The character to print
 *
 * Return: On success 1.
 * On error, -1 is returned, and errno is set appropriately.
 */
int _putchar(char cp)
{
	static int i;
	static char buf[WRITE_BUF_SIZE];

	if (cp == BUF_FLUSH || i >= WRITE_BUF_SIZE)
	{
		write(1, buf, i);
		i = 0;
	}
	if (cp != BUF_FLUSH)
		buf[i++] = cp;
	return (1);
}
#include "shell.h"
/**
 * _strlength - returns the length of a string
 * @achstr: the string whose length to check
 *
 * Return: integer length of string
 */
int _strlength(char *achstr)
{
	int i = 0;

	if (!achstr)
		return (0);

	while (*achstr++)
		i++;
	return (i);
}

/**
 * _str_comp - performs lexicogarphic comparison of two strangs.
 * @s1: the first strang
 * @s2: the second strang
 *
 * Return: negative if s1 < s2, positive if s1 > s2, zero if s1 == s2
 */
int _str_comp(char *fs, char *ss)
{
	while (*fs && *ss)
	{
		if (*fs != *ss)
			return (*fs - *ss);
		fs++;
		ss++;
	}
	if (*fs == *ss)
		return (0);
	else
		return (*fs < *ss ? -1 : 1);
}

/**
 * starts_with - checks if needle starts with haystack
 * @ssearch: string to search
 * @ssfind: the substring to find
 *
 * Return: address of next char of haystack or NULL
 */
char *starts_with(const char *ssearch, const char *ssfind)
{
	while (*ssfind)
		if (*ssfind++ != *ssearch++)
			return (NULL);
	return ((char *)ssearch);
}

/**
 * _str_cat - concatenates two strings
 * @desti: the destination buffer
 * @sbuf: the source buffer
 *
 * Return: pointer to destination buffer
 */
char *_str_cat(char *desti, char *sbuf)
{
	char *ret = desti;

	while (*desti)
		desti++;
	while (*sbuf)
		*desti++ = *sbuf++;
	*desti = *sbuf;
	return (ret);
}
#include "shell.h"
/**
 **_strn_copy - copies a string
 *@desti: the destination string to be copied to
 *@sstr: the source string
 *@cc: the amount of characters to be copied
 *Return: the concatenated string
 */
char *_strn_copy(char *desti, char *sstr, int cc)
{
	int i, j;
	char *s = desti;

	i = 0;
	while (sstr[i] != '\0' && i < cc - 1)
	{
		desti[i] = sstr[i];
		i++;
	}
	if (i < cc)
	{
		j = i;
		while (j < cc)
		{
			desti[j] = '\0';
			j++;
		}
	}
	return (s);
}

/**
 **_strncat - concatenates two strings
 *@desti: the first string
 *@str_src: the second string
 *@n: the amount of bytes to be maximally used
 *Return: the concatenated string
 */
char *_strncat(char *desti, char *sstr, int bu)
{
	int i, j;
	char *s = desti;

	i = 0;
	j = 0;
	while (desti[i] != '\0')
		i++;
	while (sstr[j] != '\0' && j < bu)
	{
		desti[i] = sstr[j];
		i++;
		j++;
	}
	if (j < bu)
		desti[i] = '\0';
	return (s);
}

/**
 **_str_chr - locates a character in a string
 *@sp: the string to be parsed
 *@sc: the character to look for
 *Return: (s) a pointer to the memory area s
 */
char *_str_chr(char *sp, char sc)
{
	do {
		if (*sp == sc)
			return (sp);
	} while (*sp++ != '\0');

	return (NULL);
}
